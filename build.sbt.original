name := "Passport"

version := "1.0-SNAPSHOT"

libraryDependencies ++= Seq(
  "pt.ist" % "fenix-framework-backend-jvstm-ojb-code-generator" % "2.4.0",
  jdbc,
  cache,
  anorm
)

play.Project.playScalaSettings

val destDirectory = settingKey[File]("The top level directory where to generate the non-base classes.")

val destDirectoryBase = settingKey[File]("The top level directory where to generate the base classes.")

val localDomainSpecsDirectory = settingKey[File]("The top level directory where the dml files can be found.")

val backendGeneratorClass = settingKey[String]("The code generator to use.")


destDirectory := baseDirectory.value / "app"

destDirectoryBase := (sourceManaged in Compile).value

localDomainSpecsDirectory := baseDirectory.value / "app" / "dml"

backendGeneratorClass := "pt.ist.fenixframework.backend.jvstmojb.codeGenerator.FenixCodeGeneratorOneBoxPerObject"


sourceGenerators in Compile <+= Def.task[Seq[File]]{
  //https://github.com/fenix-framework/fenix-framework/blob/develop/core/dml-compiler/code-generator/src/main/java/pt/ist/fenixframework/dml/CompilerArgs.java
  //https://github.com/fenix-framework/fenix-framework/blob/develop/maven/dml-maven-plugin/src/main/java/pt/ist/fenixframework/dml/maven/DmlCodeGeneratorMojo.java
  //https://github.com/fenix-framework/fenix-framework/blob/develop/maven/dml-maven-plugin/src/main/java/pt/ist/fenixframework/dml/maven/AbstractDmlCodeGeneratorMojo.java
  //https://github.com/fenix-framework/fenix-framework/blob/develop/maven/dml-maven-plugin/src/main/java/pt/ist/fenixframework/dml/maven/DmlMojoUtils.java
  var generatedFiles = Seq[File]()
  for (dmlFile <- (localDomainSpecsDirectory.value ** "*.dml").get) {
	  val cachedFun = FileFunction.cached(cacheDirectory.value / dmlFile.getName, FilesInfo.lastModified, FilesInfo.exists) { (inFiles: Set[File]) =>
			import java.net.URL
		  import java.util.{ArrayList, HashMap}
		  import pt.ist.fenixframework.dml.CompilerArgs
		  import scala.collection.JavaConverters._
		  val compileArgs = new CompilerArgs(
		    name.value,
		    destDirectory.value,
		    destDirectoryBase.value,
		    "",//This is not used
		    false,
		    Class.forName(backendGeneratorClass.value).asInstanceOf[Class[_ <: pt.ist.fenixframework.dml.CodeGenerator]],
		    Seq(dmlFile.toURI.toURL).asJava,
		    getURLsOfDMLFilesInTheDependentJars.value.asJava,
		    new HashMap[String, String])
		  pt.ist.fenixframework.DmlCompiler.compile(compileArgs)
		  println("Ran the DmlCompiler for \"" + dmlFile.getName + "\".")
		  val pathfinder = (destDirectoryBase.value ** "*_Base.java") +++ (destDirectoryBase.value / "pt" / "ist" / "fenixframework" ** "*.java")
		  pathfinder.get.toSet
    }
    generatedFiles = generatedFiles ++ cachedFun(Set(dmlFile)).toSeq
  }
  //Deletes the non base files since they were generated for Java
  (destDirectoryBase.value ** "*_Base.java").get.map{f =>
    val nonBaseFile = destDirectory.value / f.getAbsolutePath.replace(destDirectoryBase.value.getAbsolutePath, "").replace("_Base.java", ".java")
    IO.delete(nonBaseFile)
  }
  generatedFiles
}

lazy val getURLsOfDMLFilesInTheDependentJars = TaskKey[Seq[java.net.URL]]("getURLsOfDMLFilesInTheDependentJars","prints stuff")

getURLsOfDMLFilesInTheDependentJars := {
  import java.util.jar.JarInputStream
  import java.io.FileInputStream
  import java.net.URL
  var urlsToTheDMLFiles = Seq[URL]()
  val cp: Seq[File] = (dependencyClasspath in Compile).value.files
  for (f <- cp if f.getName.startsWith("fenix-framework")) {
    val jarInputStream = new JarInputStream(new FileInputStream(f));
    var jarEntry = jarInputStream.getNextJarEntry
    while (jarEntry != null) {
      if (jarEntry.getName.endsWith(".dml")) {
        urlsToTheDMLFiles :+= getClass.getResource(jarEntry.getName)
      }
      jarEntry = jarInputStream.getNextJarEntry
    }
    jarInputStream.close
  }
  urlsToTheDMLFiles.sorted(new Ordering[URL] {
    def compare(a: URL, b: URL) = a.toExternalForm().compareTo(b.toExternalForm())
  })
}

lazy val postProcessDomainClassesAndAtomicAnnotations = TaskKey[Unit]("postProcessDomainClassesAndAtomicAnnotations","Full Post Process Domain Classes")

managedClasspath in Runtime += (classDirectory in Compile).value

managedClasspath in Runtime += baseDirectory.value

unmanagedResourceDirectories in Compile += localDomainSpecsDirectory.value

postProcessDomainClassesAndAtomicAnnotations := {
  //https://github.com/fenix-framework/fenix-framework/blob/develop/core/dml-compiler/dml/src/main/java/pt/ist/fenixframework/core/Project.java
  //https://github.com/fenix-framework/fenix-framework/blob/develop/maven/dml-maven-plugin/src/main/java/pt/ist/fenixframework/dml/maven/DmlPostProcessorMojo.java
  //https://github.com/fenix-framework/fenix-framework/blob/develop/maven/dml-maven-plugin/src/main/java/pt/ist/fenixframework/dml/maven/AbstractDmlPostProcessorMojo.java
  //https://github.com/fenix-framework/fenix-framework/blob/develop/maven/dml-maven-plugin/src/main/java/pt/ist/fenixframework/dml/maven/DmlMojoUtils.java
  import pt.ist.fenixframework.core.FullPostProcessDomainClasses
  import java.net.URLClassLoader
  //We need to include the baseDirectory so the project.properties is picked up from the conf directory
  //And we also need to include the classDirectory so the _Base files generated for the external DMLs
  //(the DMLs in the dependencyClasspath jars) are also picked up
  val classesURL = Array(baseDirectory.value.toURI.toURL, (baseDirectory.value / "conf").toURI.toURL, (classDirectory in Compile).value.toURI.toURL)
  //By passing the getClass.getClassLoader as the parent ClassLoader we ensure all the jars in the dependencyClasspath are picked up
  val loader: URLClassLoader = new URLClassLoader(classesURL, getClass.getClassLoader)
  val oldContextClassLoader = Thread.currentThread().getContextClassLoader()
  Thread.currentThread().setContextClassLoader(loader)
  //This is a hack, so that Project.fromName will search for the project.properties in the conf folder
  FullPostProcessDomainClasses.apply(name.value, new File(""), loader/*oldContextClassLoader*/)//The second argument is not used
  println("Ran the FullPostProcessDomainClasses")
  import pt.ist.esw.advice.ProcessAnnotations
  import pt.ist.fenixframework.Atomic
  import pt.ist.fenixframework.atomic.AtomicContextFactory
  //For this to work the line that sets the ContextClassLoader must have been executed
  new ProcessAnnotations(
    new ProcessAnnotations.ProgramArgs(
      classOf[Atomic],
      classOf[AtomicContextFactory],
      (classDirectory in Compile).value
    )
  ).process()
  Thread.currentThread().setContextClassLoader(oldContextClassLoader)
  println("Ran the ProcessAtomicAnnotations")
}

postProcessDomainClassesAndAtomicAnnotations <<= postProcessDomainClassesAndAtomicAnnotations.dependsOn(compile in Compile)